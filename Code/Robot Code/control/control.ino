static float K[3][10] = {{-0.0, 0.87287, 2.37446, 0.0, -0.01697, -0.0, 1.47071, -0.31637, -0.0, -0.01113}, {-0.75593, -0.43644, -1.18723, -2.05662, -0.01697, -1.27456, -0.73536, 0.15818, 0.27408, -0.01113}, {0.75593, -0.43644, -1.18723, 2.05662, -0.01697, 1.27456, -0.73536, 0.15818, -0.27408, -0.01113}};
static float AKF[3][10] = {{0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0}, {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0}, {0.0, 0.0, -0.10522, 0.0, 0.0, -0.0, 12.51585, -2.69051, 0.0, 0.0}, {0.0, 0.0, 0.0, -0.10514, 0.0, 12.52012, -0.0, 0.0, -2.6908, -0.0}, {0.0, 0.0, 0.0, 0.0, -0.52683, -0.0, -0.0, 0.0, 0.0, 0.11853}, {0.0, 0.0, 0.0, -0.11084, -0.0, -15.16011, -0.0, 0.0, 0.91883, -0.0}, {0.0, 0.0, -0.11085, 0.0, 0.0, -0.0, -15.16404, 0.9197, 0.0, 0.0}, {0.0, 0.0, 30.03364, 0.0, 0.0, -0.0, 54.38423, -17.46011, 0.0, 0.0}, {0.0, 0.0, 0.0, 30.07344, -0.0, 54.43737, -0.0, 0.0, -17.47235, -0.0}, {0.0, 0.0, 0.0, -0.0, -0.02821, 0.0, -0.0, 0.0, -0.0, -3.91803}};
static float BKF_bot[3][10] = {{0.0, -3.93952, 3.93952}, {4.54896, -2.27448, -2.27448}, {-17.52692, 8.76342, 8.76342}, {0.0, 15.19822, -15.19822}, {-29.25137, -29.25137, -29.25137}};
static float LKF[3][10] = {{0.04197, 0.0, -0.0, -0.00159, 0.0008, 0.0008, 0.00381, 0.0, 0.0}, {0.0, 0.04198, -0.0, -0.0, 0.00138, -0.00138, 0.0, 0.0038, 0.0}, {0.0, 0.0, 8e-05, -8e-05, -8e-05, -8e-05, 0.0, 0.0, 0.01934}, {0.0, 0.02243, -0.0, -0.0, -0.03338, 0.03338, 0.0, 0.00102, 0.0}, {0.02242, 0.0, 0.0, 0.03855, -0.01927, -0.01927, 0.00102, 0.0, 0.0}, {0.14845, 0.0, 0.0, 0.02625, -0.01313, -0.01313, 0.00839, 0.0, 0.0}, {0.0, 0.14856, -0.0, -0.0, -0.02274, 0.02274, 0.0, 0.0084, 0.0}, {0.0, -0.0, 0.02606, -0.02438, -0.02438, -0.02438, -0.0, -0.0, 2e-05}};

float x_hat[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
float y = {0, 0, 0, 0, 0, 0, 0, 0, 0};
float u = {0, 0, 0};
long int tprev = 0;


void feedback() {

	// xhat += (t - t_prev) * (AK @ xhat + B @ u + LKF @ y)
	float d_xhat[10] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
	mat_vec_mul_plus(&AKF, &xhat, &d_xhat, 10, 10);
	mat_vec_mul_plus(&B_KF_bot, &u, &d_xhat + 5, 5, 3);
	mat_vec_mul_plus(&LKF, &y, &d_xhat, 10, 9);

	if (tprev == 0) {
		tprev = millis();
	}
	long int tnew = millis();
	float dt = (tnew - tprev) / 1000

	for (int i=0; i<10; i++) {
		xhat[i] += dt * d_xhat[i];
	}

	// tprev = t
	tprev = tnew;
	// u = K @ xhat
	u = mat_vec_mul_replace(&K, &xhat, 3, 10);
}

void read_sensors_to_y() {
	// y[0:3] = [dphix, dphiy, dphiz]
	y[0] = mpu.getGyroY();  // X axis is y
	y[1] = -mpu.getGyroX(); // Y axis is -x
	y[2] = mpu.getGyroZ();

	// y[3:6] = wheel speed measurements (wheels 1 through 3)
	y[3] = get_speed(0);
	y[4] = get_speed(1);
	y[5] = get_speed(2);

	// y[6:9] = Roll Pitch Yaw
	y[6] = mpu.getPitch(); // X axis is (y)
	y[7] = -mpu.getRoll(); // Y axis is (-x)
	y[8] = mpu.getYaw();
}

void mat_vec_mul_plus(*A, *b, *res, n, m) {
	for (int i=0; i<n; i++) {
		for (int j=0; j<m; j++) {
			res[i] += A[i*m + j] * b[j];
		}
	}
}

void mat_vec_mul_replace(*A, *b, *res, n, m) {
	for (int i=0; i<n; i++) {
		res[i] = 0;
		for (int j=0; j<m; j++) {
			res[i] += A[i*m + j] * b[j];
		}
	}
}